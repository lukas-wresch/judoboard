var lang_en = {
    add: [ "Add", "Hinzuf&uuml;gen" ],
    add_match: [ "Add Match", "Kampf hinzuf&uuml;gen" ],
    add_matchtable: [ "Add Match Table", "Kampfliste hinzuf&uuml;gen" ],
    age_group:  [ "Age group", "Altersklasse" ],
    age_groups: [ "Age groups", "Altersklassen" ],
    all_mats: [ "All Mats", "Alle Matten" ],
    birthyear: [ "Birthyear", "Geburtsjahr" ],
    break_time: [ "Break Time", "Ruhepause" ],
    club: [ "Club", "Verein"],
    configuration: [ "Configuration", "Konfiguration" ],
    description:  [ "Description", "Beschreibung" ],
    name:  [ "Name", "Name" ],
    username:  [ "Username", "Benutzername" ],
    password:  [ "Password", "Passwort" ],
    change_password:  [ "Change Password", "Passwort &auml;ndern" ],
    user:  [ "User", "Benutzer" ],
    moderator:  [ "Moderator", "Moderator" ],
    admin:  [ "Admin", "Administrator" ],
    schedule:  [ "Schedule", "Zeitplan" ],
    match_table:  [ "Match Table", "Kampfliste" ],
    match_tables:  [ "Match Tables", "Kampflisten" ],
    generate_matchtables:  [ "Generate Match Tables", "Kampflisten generieren" ],
    update_matchtable:  [ "Update Match Table", "Kampfliste &auml;ndern" ],
    delete_matchtable:  [ "Delete Match Table", "Kampfliste l&ouml;schen" ],
    new_club:  [ "New Club", "Neuer Verein" ],
    new_match: [ "New Match", "Neuer Kampf" ],
    matches: [ "Matches", "K&auml;mpfe" ],
    participants: [ "Participants", "Teilnehmer" ],
    database:  [ "Database", "Stammdaten" ],
    new_judoka:  [ "New Judoka", "Neuer Judoka" ],
    edit_judoka:  [ "Edit Judoka", "Judoka &auml;ndern" ],
    new_participant: ["New Participant", "Neuer Teilnehmer" ],
    add_participant:  [ "Add Participant", "Teilnehmer  hinzuf&uuml;gen" ],
    list_associations:  [ "List Associations", "Verb&auml;nde anzeigen" ],
    list_clubs:  [ "List Clubs", "Vereine anzeigen" ],
    list_judokas:  [ "List Judokas", "Judokas anzeigen" ],
    list_of_all_clubs:  [ "List of all Clubs", "Liste aller Vereine" ],
    list_of_all_associations:  [ "List of all Associations", "Liste aller Verb&auml;nde" ],
    list_of_all_judokas:  [ "List of all Judokas", "Liste aller Judokas" ],
    new_account:  [ "New Account", "Neues Benutzerkonto" ],
    list_accounts:  [ "List Accounts", "Benutzerkonten anzeigen" ],
    rule_set:   [ "Rule Set", "Regelwerk" ],
    rule_sets:  [ "Rule Sets", "Regelwerke" ],
    edit_rule_set:  [ "Edit Rule Set", "Regelwerk &auml;ndern" ],
    tournament:  [ "Tournament", "Turnier" ],
    tournaments:  [ "Tournaments", "Turniere" ],
    tournament_default:  [ "Tournament Default", "Turnierstandard" ],
    overview:  [ "Overview", "&Uuml;bersicht" ],
    next_matches:  [ "Next Matches", "N&auml;chste K&auml;mpfe" ],
    update_account:  [ "Update Account", "Benutzerkonto &auml;ndern" ],
    update_club:   [ "Update Club", "Verein &auml;ndern" ],
    new_rule_set:  [ "New Rule Set", "Neues Regelwerk" ],
    update_rule_set:  [ "Update Rule Set", "&Auml;ndere Regelwerk" ],
    new_tournament:  [ "New Tournament", "Neues Turnier" ],
    update_tournament:  [ "Update Tournament", "&Auml;ndere Turnier" ],
    hide_mats:  [ "Hide Mats", "Matten ausblenden" ],
    show_mats:  [ "Show Mats", "Matten anzeigen" ],
    firstname:  [ "Given name", "Vorname" ],
    lastname:  [ "Family name", "Nachname" ],
    weight:  [ "Weight", "Gewicht" ],
    gender:  [ "Gender", "Geschlecht" ],
    all:   [ "All", "Alle" ],
    male:  [ "Male", "M&auml;nnlich" ],
    female:  [ "Female", "Weiblich" ],
    settings:  [ "Settings", "Einstellungen" ],
    type:  [ "Type", "Typ" ],
    save:  [ "Save", "Speichern" ],
    weightclass:  [ "Weightclass", "Gewichtsklasse" ],
    medical_examiniations:  [ "Medical Examinations", "Medizin. Untersuch." ],
    min_weight:  [ "Minimum weight", "Mindestgewicht" ],
    max_weight:  [ "Maximum weight", "Maximalgewicht" ],
    details:  [ "Details", "Details" ],
    time:  [ "Time", "Zeit" ],
    for:  [ "For", "F&uuml;r" ],
    mat:  [ "Mat", "Matte" ],
    mats:  [ "Mats", "Matten" ],
    neutral:  [ "Neutral", "Neutral" ],
    white:  [ "White", "Wei&szlig;" ],
    blue:   [ "Blue", "Blau" ],
    white_wins: [ "White Wins", "Sieger Wei&szlig" ],
    blue_wins:  [ "Blue Wins",  "Sieger Blau" ],
    draw:   [ "Draw", "Unentschieden" ],
    name_white:  [ "Name (White)", "Name (Wei&szlig;)" ],
    name_blue:   [ "Name (Blue)", "Name (Blau)" ],
    no:  [ "No.", "Nr." ],
    select_age_groups: [ "Select Age Groups", "Altersklassen ausw&auml;hlen" ],
    status:  [ "Status", "Status" ],
    winner:  [ "Winner", "Gewinner" ],
    score:  [ "Score", "Unterwertung" ],
    scheduled:  [ "Scheduled", "Eingeplant" ],
    running:   [ "Running", "am K&auml;mpfen" ],
    concluded:  [ "Concluded", "Beendet" ],
    optional:   [ "Optional", "Optional" ],
    skipped:   [ "Skipped", "Ausgelassen" ],
    match_time:  [ "Match Time", "Kampfzeit" ],
    goldenscore_time:  [ "Golden Score Time", "Golden Score Zeit" ],
    enabled:   [ "Enabled", "Aktiviert" ],
    disabled:  [ "Disabled", "Deaktiviert" ],
    disqualification:  [ "Disqualification", "Disqualifiziert" ],
    no_disqualification:  [ "No Disqualification", "Nicht disqualifiziert" ],
    osaekomi_time_ippon:    [ "Osaekomi Time (Ippon)", "Osaekomi Zeit (Ippon)" ],
    osaekomi_time_wazaari:  [ "Osaekomi Time (Waza-Ari)", "Osaekomi Zeit (Waza-Ari)" ],
    push_up:  [ "Push Up", "Vorziehen" ],
    start_next_match:  [ "Start Next Match", "Kampf starten" ],
    end_match:  [ "End Match", "Kampf beenden" ],
    more:  [ "More", "Mehr" ],
    less:  [ "Less", "Weniger" ],
    remove:  [ "Remove", "Entfernen" ],
    options:  [ "Options", "Optionen" ],
    delete_match:  [ "Delete Match", "L&ouml;sche Kampf" ],
    delete_match_confirm:  [ "Are you sure you want to delete this match?", unescape("Willst du diesen Kampf wirklich l%F6schen?") ],
    delete_matchtable_confirm:  [ "Are you sure you want to delete this match table?",  unescape("Willst du diese Kampfliste wirklich l%F6schen?") ],
    delete_account_confirm:  [ "Are you sure you want to delete this account?", unescape("Willst du dieses Benutzerkonto wirklich l%F6schen?") ],
    delete_judoka:  [ "Delete", "L&ouml;schen" ],
    delete_judoka_confirm:  [ "Are you sure you want to delete this judoka?", unescape("Willst du diesen Judoka wirklich l%F6schen?") ],
    delete_club_confirm:  [ "Are you sure you want to delete this club/association?", unescape("Willst du diesen Verein/Assoziation wirklich l%F6schen?") ],
    empty_tournament_confirm:  [ "Are you sure you want to delete all match results of this tournament?", unescape("Willst du wirklich alle Ergebnisse dieses Turnieres l%F6schen?") ],
    delete_tournament_confirm:  [ "Are you sure you want to completely delete this tournament?", unescape("Willst du wirklich dieses Turnier vollst%E4ndig l%F6schen?") ],
    delete_rules_confirm:  [ "Are you sure you want to delete this rule set?", unescape("Willst du wirklich dieses Regelwerk l%F6schen?") ],
    shutdown_confirm:  [ "Are you sure you want to shutdown Judoboard?", "Soll Judoboard wirklich heruntergefahren werden?" ],
    year: ["Year", "Jahr" ],
    show_matches_on: [ "Show matches on", "K&auml;mpfe auf Matte" ],
}



function translate(keyword)
{
  console.log("Translating " + keyword);
  //return eval('lang_en.' + keyword + "[0]");
  return eval('lang_en.' + keyword + "[1]");
}

var lang_de = {
    add: "Hinzuf&uuml;gen",
    add_match: "Kampf hinzuf&uuml;gen",
    add_matchtable: "Kampfliste hinzuf&uuml;gen",
    add_participant: "Teilnehmer  hinzuf&uuml;gen",
    age_group: "Altersklasse",
    change_password: "Passwort &auml;ndern",
    description: "Beschreibung",
    name: "Name",
    username: "Benutzername",
    password: "Passwort",
    user: "Benutzer",
    moderator: "Moderator",
    admin: "Administrator",
    schedule: "Zeitplan",
    match_tables: "Kampflisten",
    generate_matchtables: "Kampflisten generieren",
    update_matchtable: "Kampfliste &auml;ndern",
    delete_matchtable: "Kampfliste l&ouml;schen",
    matchtable: "Kampfliste",
    matchtables: "Kampflisten",
    new_club: "Neuer Verein",
    participants: "Teilnehmer",
    database: "Stammdaten",
    new_judoka: "Neuer Judoka",
    edit_judoka: "Judoka &auml;ndern",
    list_clubs: "Vereine anzeigen",
    list_judokas: "Judokas anzeigen",
    list_of_all_clubs: "Liste aller Vereine",
    list_of_all_judokas: "Liste aller Judokas",
    //new_account: "Neuer Account",
    list_accounts: "Accounts anzeigen",
    rule_set:  "Regelwerk",
    rule_sets: "Regelwerke",
    edit_rule_set: "Regelwerk &auml;ndern",
    tournament: "Turnier",
    tournaments: "Turniere",
    tournament_default: "Turnierstandard",
    overview: "&Uuml;bersicht",
    matches: "K&auml;mpfe",
    next_matches: "N&auml;chste K&auml;mpfe",
    new_account: "Neues Benutzerkonto",
    update_account: "Benutzerkonto &auml;ndern",
    update_club: "Verein &auml;ndern",
    new_rule_set: "Neues Regelwerk",
    update_rule_set: "&Auml;ndere Regelwerk",
    new_tournament: "Neues Turnier",
    update_tournament: "&Auml;ndere Turnier",
    hide_mats: "Matten ausblenden",
    show_mats: "Matten anzeigen",
    firstname: "Vorname",
    lastname:  "Nachname",
    weight: "Gewicht",
    medical_examiniations: "Medizin. Untersuch.",
    min_weight: "Mindestgewicht",
    max_weight: "Maximalgewicht",
    gender: "Geschlecht",
    all: "Alle",
    male: "M&auml;nnlich",
    female: "Weiblich",
    settings: "Einstellungen",
    type: "Typ",
    save: "Speichern",
    weightclass: "Gewichtsklasse",
    details: "Details",
    time: "Zeit",
    for: "F&uuml;r",
    mat: "Matte",
    mats: "Matten",
    neutral: "Neutral",
    white: "Wei&szlig;",
    draw: "Unentschieden",
    blue: "Blau",
    name_white: "Name (Wei&szlig;)",
    name_blue: "Name (Blau)",
    no: "Nr.",
    status: "Status",
    winner: "Gewinner",
    score: "Unterwertung",
    scheduled: "Eingeplant",
    running: "am K&auml;mpfen",
    concluded: "Beendet",
    optional: "Optional",
    skipped: "Ausgelassen",
    match_time: "Kampfzeit",
    goldenscore_time: "Golden Score Zeit",
    enabled:  "Aktiviert",
    disabled: "Deaktiviert",
    disqualification: "Disqualifiziert",
    no_disqualification: "Nicht disqualifiziert",
    osaekomi_time_ippon:   "Osaekomi Zeit (Ippon)",
    osaekomi_time_wazaari: "Osaekomi Zeit (Waza-Ari)",
    push_up: "Vorziehen",
    start_next_match: "Kampf starten",
    end_match: "Kampf beenden",
    more: "Mehr",
    less: "Weniger",
    remove: "Entfernen",
    options: "Optionen",
    delete_match: "L&ouml;sche Kampf",
    delete_match_confirm: unescape("Willst du diesen Kampf wirklich l%F6schen?"),
    delete_matchtable_confirm: unescape("Willst du diese Kampfliste wirklich l%F6schen?"),
    delete_account_confirm: unescape("Willst du dieses Benutzerkonto wirklich l%F6schen?"),
    delete_judoka: "L&ouml;schen",
    delete_judoka_confirm: unescape("Willst du diesen Judoka wirklich l%F6schen?"),
    delete_club_confirm: unescape("Willst du diesen Verein/Assoziation wirklich l%F6schen?"),
    empty_tournament_confirm: unescape("Willst du wirklich alle Ergebnisse dieses Turnieres l%F6schen?"),
    delete_tournament_confirm: unescape("Willst du wirklich dieses Turnier vollst%E4ndig l%F6schen?"),
    delete_rules_confirm: unescape("Willst du wirklich dieses Regelwerk l%F6schen?"),
    shutdown_confirm: "Soll Judoboard wirklich heruntergefahren werden?",
    year: "Jahr",
}



var lang = lang_de;


const zeroPad = (num, places) => String(num).padStart(places, '0')



function NiceTime(timestamp)
{
  return Math.floor(timestamp/(1000*60)) + ':' + zeroPad(Math.floor((timestamp/1000))%60, 2) + '.' + Math.floor((timestamp%1000)/100);
}

function NiceTimeMS(timestamp)
{
  return Math.floor(timestamp/(1000*60)) + ':' + zeroPad(Math.floor((timestamp/1000))%60, 2) + '.' + zeroPad(timestamp%1000, 3);
}

function NiceLargeTime(timestamp)
{
  return Math.floor(timestamp/(1000*60*60)) + ':' + zeroPad(Math.floor(timestamp/(1000*60)%60), 2) + ':' + zeroPad(Math.floor((timestamp/1000))%60, 2);
}



function URLEncode(obj)
{
  var str = [];
  for (var p in obj)
  {
    if (obj.hasOwnProperty(p))
      str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
  }
  return str.join("&");
}



function URLDecode(input, variable)
{
  if (typeof input === 'undefined')
    return false;

  var query = input.split("?");

  if (typeof query[1] === 'undefined')
    return false;

  var vars = query[1].split("&");

  for (var i=0;i < vars.length;i++)
  {
    var pair = vars[i].split("=");
    if (pair[0] == variable)
      return pair[1];
  }
  return false;
}



function GetQueryVariable(variable)
{
    var query = window.location.search.substring(1);
    var vars = query.split("&");
    for (var i=0;i < vars.length;i++)
    {
          var pair = vars[i].split("=");
          if (pair[0] == variable)
            return pair[1];
    }
    return false;
}



function Ajax(url)
{
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function()
  {
    if (this.readyState == 4 && this.status == 200)
    {
      if (this.response != "ok")
        alert("Error: " + this.response);
    }
  };

  xhttp.open("GET", url);
  xhttp.send();
  return false;
}



function AjaxCallback(url, callback)
{
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function()
  {
    if (this.readyState == 4 && this.status == 200 && typeof callback !== 'undefined')
      callback(this.responseText);
  };

  xhttp.open("GET", url);
  xhttp.send();
}



function AjaxPost(url, params, callback)
{
  var xhttp = new XMLHttpRequest();
  xhttp.open("POST", url);
  xhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

  xhttp.onreadystatechange = function()
  {
    if (this.readyState == 4 && this.status == 200)
    {
        if (this.response == "ok")
          callback();
        else
          alert("Error: " + this.response);
      }
  };

  xhttp.send(params);
}



function AjaxPostToYaml(url, params, callback)
{
  var xhttp = new XMLHttpRequest();
  xhttp.open("POST", url);
  xhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

  xhttp.onreadystatechange = function()
  {
    if (this.readyState == 4 && this.status == 200 && typeof callback !== 'undefined')
      callback(this.responseText);
  };

  xhttp.send(params);
}



function Color(index)
{
  if (index == 1)
    return "#0bf8";
  else if (index == 2)
    return "#e338";
  else if (index == 3)
    return "#5d58";
  else if (index == 4)
    return "#ff68";
  else if (index == 5)
    return "#d0d8";
  else if (index == 6)
    return "#8658";
  else if (index == 7)
    return "#4ed8";
  else if (index == 8)
    return "#f858";
  else if (index == 9)
    return "#a0a8";
  else if (index == 10)
    return "#fe88";

  return "#fff";
}



function navigate(url)
{
  window.clearInterval(TimerID);

  window.location = '/#' + url;
  URL = url;

  if (window.innerWidth <= 900)//Mobile
    slideout.close();

  return false;
}


window.onhashchange = function(e)
{
  console.log(location.hash.slice(1));
  navigate(location.hash.slice(1));
  $( "#main" ).load(URL);
};


var StreamTimer;
var StreamUpdate = 0;

function Stream()
{
  document.getElementById("img").src = "ajax/mat/screenshot?id=1&up=" + StreamUpdate;
  StreamUpdate++;
}



function GetRuleSets(callback)
{
  AjaxCallback("ajax/rule/list", function(response) {
    console.log(response);
    var res = YAML.parse(response);

    var rules = document.getElementById("rule");

    while (rules.length >= 1)
      rules.remove(rules.length-1);

    var option = document.createElement("option");
    option.value = 0;
    option.text = "(None)";
    rules.add(option);

    for (const rule of res.rules)
    {
      var option = document.createElement("option");

      option.value = rule.uuid;

      if (typeof res.default !== 'undefined' && rule.uuid == res.default)
        option.text = rule.name + " (" + lang.tournament_default + ")";
      else
        option.text = rule.name;

      rules.add(option);
    }

    if (typeof res.default !== 'undefined' && rule.uuid == res.default)
        rules.value = res.default;

    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetAgeGroups(callback)
{
  AjaxCallback("ajax/age_groups/list", function(response) {
    console.log(response);
    var res = YAML.parse(response);

    var ages = document.getElementById("age_group");

    while (ages.length >= 1)
      ages.remove(ages.length-1);

    var option = document.createElement("option");
    option.value = 0;
    option.text = "(None)";
    ages.add(option);

    for (const age of res)
    {
      var option = document.createElement("option");
      option.value = age.uuid;
      option.text  = age.name;
      ages.add(option);
    }

    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetClubs(callback, query = "")
{
  AjaxCallback("ajax/club/list?" + query, function(response) {
    console.log(response);
    var res = YAML.parse(response);

    var clubs = document.getElementById("clubs");

    while (clubs.length >= 1)
      clubs.remove(clubs.length-1);

    var option = document.createElement("option");
    option.value = 0;
    option.text  = "(None)";
    clubs.add(option);

    for (const club of res)
    {
      var option = document.createElement("option");
      option.value = club.uuid;
      option.text  = club.name;
      clubs.add(option);
    }

    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetAssociations(callback)
{
  AjaxCallback("ajax/association/list", function(response) {
    console.log(response);
    var res = YAML.parse(response);

    var clubs = document.getElementById("clubs");

    while (clubs.length >= 1)
      clubs.remove(clubs.length-1);

    var option = document.createElement("option");
    option.value = 0;
    option.text  = "(None)";
    clubs.add(option);

    for (const club of res)
    {
      var option = document.createElement("option");
      option.value = club.uuid;
      option.text  = club.name;
      clubs.add(option);
    }

    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetAssociationsWithoutParents(callback)
{
  AjaxCallback("ajax/association/list?only_children=true", function(response) {
    console.log(response);
    var res = YAML.parse(response);

    var clubs = document.getElementById("clubs");

    while (clubs.length >= 1)
      clubs.remove(clubs.length-1);

    for (const club of res)
    {
      var option = document.createElement("option");
      option.value = club.uuid;
      option.text  = club.name;
      clubs.add(option);
    }

    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetColors(callback)
{
  AjaxCallback("ajax/colors/get", function(response) {
    var res = response.split(",");

    if (res.length < 1)
      return;

    var color = document.getElementById("color");

    while (color.length >= 1)
      color.remove(color.length-1);

    for (var i=0; i < res.length;)
    {
      var option = document.createElement("option");
      option.value = res[i++];
      option.text  = res[i++];
      option.style.backgroundColor = res[i++].substring(0, 4);

      color.add(option);
    }

    color.onchange = function(e)
    {
      for (var i=0; i < color.length;i++)
      {
        if (color.children[i].value == color.value)
          color.style.backgroundColor = color.children[i].style.backgroundColor;
      }
    }


    if (typeof callback !== 'undefined')
      callback();
  });
}



function GetMats(callback)
{
  AjaxCallback("ajax/config/get_mats", function(response) {
    var res = YAML.parse(response);

    if (res.length < 2)
      return;

    var ui_mats = document.getElementById("mat");

    for (const mat of res.mats)
    {
      var option = document.createElement("option");
      option.text  = mat.name;
      option.value = mat.id;

      ui_mats.add(option);
    }

    if (typeof callback !== 'undefined')
      callback();
  });
}