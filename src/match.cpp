#include <sstream>
#include <fstream>
#include "../ZED/include/csv.h"
#include "../ZED/include/log.h"
#include "match.h"
#include "tournament.h"



using namespace Judoboard;



RuleSet s_default_rules;



Match::Match(const ITournament* Tournament, Judoka* White, Judoka* Blue, uint32_t MatID) : Schedulable(Tournament)
{
	m_White.m_Judoka = White;
	m_Blue.m_Judoka  = Blue;
	SetMatID(MatID);
}



Match::Match(const YAML::Node& Yaml, ITournament* Tournament) : Schedulable(Yaml, Tournament)
{
	if (!Yaml.IsMap())
		return;

	if (Yaml["white"] && Tournament)
		m_White.m_Judoka = Tournament->FindParticipant(Yaml["white"].as<std::string>());
	if (Yaml["blue"] && Tournament)
		m_Blue.m_Judoka  = Tournament->FindParticipant(Yaml["blue"].as<std::string>());

	if (Yaml["state"])
		m_State = (Status)Yaml["state"].as<int>();
	if (Yaml["winner"])
		m_Result.m_Winner = (Winner)Yaml["winner"].as<int>();
	if (Yaml["score"])
		m_Result.m_Score = (Score)Yaml["score"].as<int>();
	if (Yaml["time"])
		m_Result.m_Time = Yaml["time"].as<int>();

	if (Yaml["rule_set"] && Tournament)
		m_Rules = Tournament->FindRuleSet(Yaml["rule_set"].as<std::string>());

	if (Yaml["match_table"] && Tournament)
		m_Table = Tournament->FindMatchTable(Yaml["match_table"].as<std::string>());

	if (Yaml["dependency_white"])
		m_White.m_Dependency = (DependencyType)Yaml["dependency_white"].as<int>();
	if (Yaml["dependency_blue"])
		m_Blue.m_Dependency = (DependencyType)Yaml["dependency_blue"].as<int>();

	if (Yaml["dependent_match_white"] && Tournament)
		m_White.m_DependentMatch = Tournament->FindMatch(Yaml["dependent_match_white"].as<std::string>());
	if (Yaml["dependent_match_blue"] && Tournament)
		m_Blue.m_DependentMatch  = Tournament->FindMatch(Yaml["dependent_match_blue"].as<std::string>());

	if (Yaml["is_auto_generated"])
		m_IsAutoGenerated = Yaml["is_auto_generated"].as<bool>();

	if (Yaml["log"])
		m_Log << Yaml["log"];
}



void Match::operator >>(ZED::CSV& Stream) const
{
	Schedulable::operator >>(Stream);

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ZED::Log::Error("NOT IMPLEMENTED");//DEBUG NOT IMPLEMENTED
	else
		Stream << (std::string)GetFighter(Fighter::White)->GetUUID() << (std::string)GetFighter(Fighter::Blue)->GetUUID() << m_State;

	Stream << m_Result.m_Winner << m_Result.m_Score << m_Result.m_Time;

	if (m_Rules)
		Stream << (std::string)m_Rules->GetUUID();
	else
		Stream << "-";

	if (m_Table)
		Stream << (std::string)m_Table->GetUUID();
	else
		Stream << "-";

	Stream << IsAutoGenerated();

	if (HasConcluded() || IsRunning())
		m_Log >> Stream;

	Stream.AddNewline();//Also needed to flush the stream
}



void Match::operator >>(YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Schedulable::operator >>(Yaml);

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ZED::Log::Error("NOT IMPLEMENTED");//DEBUG NOT IMPLEMENTED
	else
	{
		Yaml << YAML::Key << "white" << YAML::Value << (std::string)GetFighter(Fighter::White)->GetUUID();
		Yaml << YAML::Key << "blue"  << YAML::Value << (std::string)GetFighter(Fighter::Blue )->GetUUID();
	}

	Yaml << YAML::Key << "state"  << YAML::Value << (int)m_State;
	Yaml << YAML::Key << "winner" << YAML::Value << (int)m_Result.m_Winner;
	Yaml << YAML::Key << "score"  << YAML::Value << (int)m_Result.m_Score;
	Yaml << YAML::Key << "time"   << YAML::Value << m_Result.m_Time;

	if (m_Rules)
		Yaml << YAML::Key << "rule_set" << YAML::Value << (std::string)m_Rules->GetUUID();

	if (m_Table)
		Yaml << YAML::Key << "match_table" << YAML::Value << (std::string)m_Table->GetUUID();

	if (m_White.m_Dependency != DependencyType::None)
		Yaml << YAML::Key << "dependency_white" << YAML::Value << (int)m_White.m_Dependency;
	if (m_Blue.m_Dependency != DependencyType::None)
		Yaml << YAML::Key << "dependency_blue"  << YAML::Value << (int)m_Blue.m_Dependency;

	if (m_White.m_DependentMatch)
		Yaml << YAML::Key << "dependent_match_white" << YAML::Value << (std::string)m_White.m_DependentMatch->GetUUID();
	if (m_Blue.m_DependentMatch)
		Yaml << YAML::Key << "dependent_match_blue"  << YAML::Value << (std::string)m_Blue.m_DependentMatch->GetUUID();

	Yaml << YAML::Key << "is_auto_generated" << YAML::Value << IsAutoGenerated();

	if (HasConcluded() || IsRunning())
	{
		Yaml << YAML::Key << "log" << YAML::Value;
		m_Log >> Yaml;
	}

	Yaml << YAML::EndMap;
}



Status Match::GetStatus() const
{
	if (m_White.m_Dependency == DependencyType::BestOfThree)
	{
		if (HasUnresolvedDependency())
			return Status::Optional;

		//Check if won by the same person
		if (m_White.m_DependentMatch && m_Blue.m_DependentMatch)
		{
			if (m_White.m_DependentMatch->GetWinner() &&
				m_Blue.m_DependentMatch->GetWinner()  &&
				m_White.m_DependentMatch->GetWinner()->GetUUID() == m_Blue.m_DependentMatch->GetWinner()->GetUUID())
				return Status::Skipped;//Skip match
		}

		return m_State;
	}
	return m_State;
}



Judoka* Match::GetFighter(Fighter Fighter)
{
	if (Fighter == Fighter::White)
		return m_White.m_Judoka;

	return m_Blue.m_Judoka;
}



const Judoka* Match::GetFighter(Fighter Fighter) const
{
	if (Fighter == Fighter::White)
		return m_White.m_Judoka;

	return m_Blue.m_Judoka;
}



bool Match::Contains(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetUUID() == Judoka.GetUUID())
		return true;

	if (m_Blue.m_Judoka  && m_Blue.m_Judoka->GetUUID()  == Judoka.GetUUID())
		return true;

	return false;
}



Fighter Match::GetColorOfFighter(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetUUID() == Judoka.GetUUID())
		return Fighter::White;
	return Fighter::Blue;
}



const Judoka* Match::GetEnemyOf(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetUUID() == Judoka.GetUUID())
		return m_Blue.m_Judoka;

	if (m_Blue.m_Judoka  && m_Blue.m_Judoka->GetUUID()  == Judoka.GetUUID())
		return m_White.m_Judoka;

	return nullptr;
}



const Judoka* Match::GetWinner() const
{
	if (!HasConcluded())
		return nullptr;

	auto result = GetMatchResult();

	if (result.m_Winner == Winner::Draw)
		return nullptr;

	if (result.m_Winner == Winner::White)
		return m_White.m_Judoka;
	else
		return m_Blue.m_Judoka;
}



const Judoka* Match::GetLoser() const
{
	if (!HasConcluded())
		return nullptr;

	auto result = GetMatchResult();

	if (result.m_Winner == Winner::Draw)
		return nullptr;

	if (result.m_Winner == Winner::White)
		return m_Blue.m_Judoka;
	else
		return m_White.m_Judoka;
}



void Match::SetDependency(Fighter Fighter, DependencyType Type, const Match* Reference)
{
	if (Fighter == Fighter::White)
	{
		m_White.m_Dependency = Type;
		m_White.m_DependentMatch = Reference;
	}
	else
	{
		m_Blue.m_Dependency = Type;
		m_Blue.m_DependentMatch = Reference;
	}
}



void Match::SetBestOfThree(const Match* Reference1, const Match* Reference2)
{
	SetDependency(Fighter::White, DependencyType::BestOfThree, Reference1);
	SetDependency(Fighter::Blue,  DependencyType::BestOfThree, Reference2);
}



bool Match::HasUnresolvedDependency() const
{
	if (m_White.m_DependentMatch)
		if (!m_White.m_DependentMatch->HasConcluded())
			return true;

	if (m_Blue.m_DependentMatch)
		if (!m_Blue.m_DependentMatch->HasConcluded())
			return true;

	return false;
}



const std::vector<const Match*> Match::GetDependentMatches() const
{
	std::vector<const Match*> ret;

	if (m_White.m_DependentMatch)
		ret.emplace_back(m_White.m_DependentMatch);
	if (m_Blue.m_DependentMatch)
		ret.emplace_back(m_Blue.m_DependentMatch);

	return ret;
}



const RuleSet& Match::GetRuleSet() const
{
	if (m_Rules)
		return *m_Rules;
	if (m_Table)
		return m_Table->GetRuleSet();
	if (GetTournament() && GetTournament()->GetDefaultRuleSet())
		return *GetTournament()->GetDefaultRuleSet();

	ZED::Log::Debug("Could not find rule set, using the default rule set");

	return s_default_rules;
}



ZED::CSV Match::ToString() const
{
	ZED::CSV ret;

	ret << (std::string)GetUUID();

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ret << "???,???";
	else
		ret << GetFighter(Fighter::White)->GetName() << GetFighter(Fighter::Blue)->GetName();

	ret << GetMatID() << (int)GetStatus() << GetColor().ToHexString();

	if (GetMatchTable())
		ret << (std::string)GetMatchTable()->GetUUID() << GetMatchTable()->GetDescription();
	else
		ret << "0,- - -";

	return ret;
}



void Match::ToString(YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Yaml << YAML::Key << "uuid" << YAML::Value << (std::string)GetUUID();

	if (GetFighter(Fighter::White))
		Yaml << YAML::Key << "white_name" << YAML::Value << GetFighter(Fighter::White)->GetName();
	else
	{
		Yaml << YAML::Key << "white_dependency_type" << YAML::Value << (int)m_White.m_Dependency;
		if (m_White.m_DependentMatch)
			Yaml << YAML::Key << "white_dependency_uuid" << YAML::Value << (std::string)m_White.m_DependentMatch->GetUUID();
	}

	if (GetFighter(Fighter::Blue))
		Yaml << YAML::Key << "blue_name"  << YAML::Value << GetFighter(Fighter::Blue)->GetName();
	else
	{
		Yaml << YAML::Key << "blue_dependency_type" << YAML::Value << (int)m_Blue.m_Dependency;
		if (m_Blue.m_DependentMatch)
			Yaml << YAML::Key << "blue_dependency_uuid" << YAML::Value << (std::string)m_Blue.m_DependentMatch->GetUUID();
	}

	Yaml << YAML::Key << "mat_id" << YAML::Value << GetMatID();
	Yaml << YAML::Key << "state"  << YAML::Value << (int)GetStatus();
	Yaml << YAML::Key << "color"  << YAML::Value << GetColor().ToHexString();

	if (m_Rules)
		Yaml << YAML::Key << "rule_set" << YAML::Value << (std::string)m_Rules->GetUUID();

	if (GetMatchTable())
	{
		Yaml << YAML::Key << "match_table" << YAML::Value << (std::string)GetMatchTable()->GetUUID();
		Yaml << YAML::Key << "match_table_name" << YAML::Value << GetMatchTable()->GetDescription();
	}

	Yaml << YAML::Key << "winner" << YAML::Value << (int)m_Result.m_Winner;
	Yaml << YAML::Key << "score"  << YAML::Value << (int)m_Result.m_Score;
	Yaml << YAML::Key << "time"   << YAML::Value << m_Result.m_Time;

	Yaml << YAML::EndMap;
}



void Match::EndMatch()
{
	m_State = Status::Concluded;

	if (m_White.m_Judoka)
		m_White.m_Judoka->StartBreak();
	if (m_Blue.m_Judoka)
		m_Blue.m_Judoka->StartBreak();

	if (GetTournament())
		GetTournament()->OnMatchConcluded(*this);
}