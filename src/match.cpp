#include <sstream>
#include <fstream>
#include "../ZED/include/csv.h"
#include "../ZED/include/log.h"
#include "match.h"
#include "tournament.h"



using namespace Judoboard;



RuleSet s_default_rules;



Match::Match(const ITournament* Tournament, Judoka* White, Judoka* Blue, uint32_t MatID) : Schedulable(Tournament)
{
	m_White.m_Judoka = White;
	m_Blue.m_Judoka  = Blue;
	SetMatID(MatID);
}



Match::Match(ZED::CSV& Stream, ITournament* Tournament) : Schedulable(Stream, Tournament)
{
	std::string whiteUUID, blueUUID;

	Stream >> whiteUUID >> blueUUID;
	Stream >> m_State;
	Stream >> m_Result.m_Winner >> m_Result.m_Score >> m_Result.m_Time;

	std::string rulesUUID;
	Stream >> rulesUUID;

	if (rulesUUID.length() > 1 && Tournament)
		m_Rules = Tournament->FindRuleSet(UUID(std::move(rulesUUID)));

	std::string matchtableUUID;
	Stream >> matchtableUUID;

	if (matchtableUUID.length() > 1 && Tournament)
	{
		m_Table = Tournament->FindMatchTable(UUID(std::move(matchtableUUID)));
		if (!m_Table)
			ZED::Log::Error("Could not find match table!");
	}

	if (Tournament)
	{
		m_White.m_Judoka = Tournament->FindParticipant(UUID(std::move(whiteUUID)));
		m_Blue.m_Judoka  = Tournament->FindParticipant(UUID(std::move(blueUUID)));
	}

	bool auto_generated;
	Stream >> auto_generated;
	SetAutoGenerated(auto_generated);

	if (HasConcluded() || IsRunning())
		m_Log << Stream;
}



Match::Match(const YAML::Node& Yaml, ITournament* Tournament) : Schedulable(Yaml, Tournament)
{
	if (Yaml["white"] && Tournament)
		m_White.m_Judoka = Tournament->FindParticipant(Yaml["white"].as<std::string>());
	if (Yaml["blue"] && Tournament)
		m_Blue.m_Judoka  = Tournament->FindParticipant(Yaml["blue"].as<std::string>());

	if (Yaml["state"])
		m_State = (Status)Yaml["state"].as<int>();
	if (Yaml["winner"])
		m_Result.m_Winner = (Winner)Yaml["winner"].as<int>();
	if (Yaml["score"])
		m_Result.m_Score = (Score)Yaml["score"].as<int>();
	if (Yaml["time"])
		m_Result.m_Time = Yaml["time"].as<int>();

	if (Yaml["rule_set"] && Tournament)
		m_Rules = Tournament->FindRuleSet(Yaml["rule_set"].as<std::string>());

	if (Yaml["match_table"] && Tournament)
		m_Table = Tournament->FindMatchTable(Yaml["match_table"].as<std::string>());

	if (Yaml["is_auto_generated"])
		m_IsAutoGenerated = Yaml["is_auto_generated"].as<bool>();

	if (Yaml["log"])
		m_Log << Yaml["log"];
}



void Match::operator >>(ZED::CSV& Stream) const
{
	Schedulable::operator >>(Stream);

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ZED::Log::Error("NOT IMPLEMENTED");//DEBUG NOT IMPLEMENTED
	else
		Stream << (std::string)GetFighter(Fighter::White)->GetUUID() << (std::string)GetFighter(Fighter::Blue)->GetUUID() << m_State;

	Stream << m_Result.m_Winner << m_Result.m_Score << m_Result.m_Time;

	if (m_Rules)
		Stream << (std::string)m_Rules->GetUUID();
	else
		Stream << "-";

	if (m_Table)
		Stream << (std::string)m_Table->GetUUID();
	else
		Stream << "-";

	Stream << IsAutoGenerated();

	if (HasConcluded() || IsRunning())
		m_Log >> Stream;

	Stream.AddNewline();//Also needed to flush the stream
}



void Match::operator >>(YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Schedulable::operator >>(Yaml);

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ZED::Log::Error("NOT IMPLEMENTED");//DEBUG NOT IMPLEMENTED
	else
	{
		Yaml << YAML::Key << "white" << YAML::Value << (std::string)GetFighter(Fighter::White)->GetUUID();
		Yaml << YAML::Key << "blue"  << YAML::Value << (std::string)GetFighter(Fighter::Blue )->GetUUID();
	}

	Yaml << YAML::Key << "state"  << YAML::Value << (int)m_State;
	Yaml << YAML::Key << "winner" << YAML::Value << (int)m_Result.m_Winner;
	Yaml << YAML::Key << "score"  << YAML::Value << (int)m_Result.m_Score;
	Yaml << YAML::Key << "time"   << YAML::Value << m_Result.m_Time;

	if (m_Rules)
		Yaml << YAML::Key << "rule_set" << YAML::Value << (std::string)m_Rules->GetUUID();

	if (m_Table)
		Yaml << YAML::Key << "match_table" << YAML::Value << (std::string)m_Table->GetUUID();

	Yaml << YAML::Key << "is_auto_generated" << YAML::Value << IsAutoGenerated();

	if (HasConcluded() || IsRunning())
	{
		Yaml << YAML::Key << "log" << YAML::Value;
		m_Log >> Yaml;
	}

	Yaml << YAML::EndMap;
}



Judoka* Match::GetFighter(Fighter Fighter)
{
	if (Fighter == Fighter::White)
		return m_White.m_Judoka;

	return m_Blue.m_Judoka;
}



const Judoka* Match::GetFighter(Fighter Fighter) const
{
	if (Fighter == Fighter::White)
		return m_White.m_Judoka;

	return m_Blue.m_Judoka;
}



bool Match::Contains(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetID() == Judoka.GetID())
		return true;

	if (m_Blue.m_Judoka  && m_Blue.m_Judoka->GetID()  == Judoka.GetID())
		return true;

	return false;
}



Fighter Match::GetColorOfFighter(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetID() == Judoka.GetID())
		return Fighter::White;
	return Fighter::Blue;
}



const Judoka* Match::GetEnemyOf(const Judoka& Judoka) const
{
	if (m_White.m_Judoka && m_White.m_Judoka->GetID() == Judoka.GetID())
		return m_Blue.m_Judoka;

	if (m_Blue.m_Judoka  && m_Blue.m_Judoka->GetID()  == Judoka.GetID())
		return m_White.m_Judoka;

	return nullptr;
}



const Judoka* Match::GetWinningJudoka() const
{
	if (!HasConcluded())
		return nullptr;

	auto result = GetMatchResult();

	if (result.m_Winner == Winner::Draw)
		return nullptr;

	if (result.m_Winner == Winner::White)
		return m_White.m_Judoka;
	else
		return m_Blue.m_Judoka;
}



const std::vector<Match*> Match::GetDependentMatches()
{
	std::vector<Match*> ret;

	if (m_White.m_PreviousMatch)
		ret.emplace_back(m_White.m_PreviousMatch);
	if (m_Blue.m_PreviousMatch)
		ret.emplace_back(m_Blue.m_PreviousMatch);

	return ret;
}



const std::vector<const Match*> Match::GetDependentMatches() const
{
	std::vector<const Match*> ret;

	if (m_White.m_PreviousMatch)
		ret.emplace_back(m_White.m_PreviousMatch);
	if (m_Blue.m_PreviousMatch)
		ret.emplace_back(m_Blue.m_PreviousMatch);

	return ret;
}



const RuleSet& Match::GetRuleSet() const
{
	if (m_Rules)
		return *m_Rules;
	if (m_Table)
		return m_Table->GetRuleSet();
	if (GetTournament() && GetTournament()->GetDefaultRuleSet())
		return *GetTournament()->GetDefaultRuleSet();

	ZED::Log::Debug("Could not find rule set, using the default rule set");

	return s_default_rules;
}



ZED::CSV Match::ToString() const
{
	ZED::CSV ret;

	ret << GetID();

	if (!GetFighter(Fighter::White) || !GetFighter(Fighter::Blue))
		ret << "???,???";
	else
		ret << GetFighter(Fighter::White)->GetName() << GetFighter(Fighter::Blue)->GetName();

	ret << GetMatID() << m_State << GetColor().ToHexString();

	if (GetMatchTable())
		ret << GetMatchTable()->GetID() << GetMatchTable()->GetName();
	else
		ret << "0,- - -";

	return ret;
}



void Match::ToString(YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Yaml << YAML::Key << "uuid" << YAML::Value << (std::string)GetUUID();

	if (GetFighter(Fighter::White))
		Yaml << YAML::Key << "white_name" << YAML::Value << GetFighter(Fighter::White)->GetName();
	if (GetFighter(Fighter::Blue))
		Yaml << YAML::Key << "blue_name"  << YAML::Value << GetFighter(Fighter::Blue)->GetName();

	Yaml << YAML::Key << "mat_id" << YAML::Value << GetMatID();
	Yaml << YAML::Key << "state"  << YAML::Value << (int)m_State;
	Yaml << YAML::Key << "color"  << YAML::Value << GetColor().ToHexString();

	if (GetMatchTable())
	{
		Yaml << YAML::Key << "match_table" << YAML::Value << (std::string)GetMatchTable()->GetUUID();
		Yaml << YAML::Key << "match_table_name" << YAML::Value << GetMatchTable()->GetName();
	}

	Yaml << YAML::EndMap;
}



ZED::CSV Match::AllToString() const
{
	return ToString() << m_Result.m_Winner << m_Result.m_Score << m_Result.m_Time << GetRuleSet().GetID();
}



void Match::EndMatch()
{
	m_State = Status::Concluded;

	if (m_White.m_Judoka)
		m_White.m_Judoka->StartBreak();
	if (m_Blue.m_Judoka)
		m_Blue.m_Judoka->StartBreak();

	if (GetTournament())
		GetTournament()->OnMatchConcluded(*this);
}