#include <algorithm>
#include <random>
#include "single_elimination.h"
#include "tournament.h"
#include "localizer.h"
#include "match.h"



using namespace Judoboard;



SingleElimination::SingleElimination(const ITournament* Tournament, Weight MinWeight, Weight MaxWeight)
	: Weightclass(Tournament, MinWeight, MaxWeight)
{
}



SingleElimination::SingleElimination(const YAML::Node& Yaml, ITournament* Tournament) : Weightclass(Yaml, Tournament)
{
}



void SingleElimination::operator >> (YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Weightclass::operator >>(Yaml);

	Yaml << YAML::EndMap;
}



void SingleElimination::ToString(YAML::Emitter& Yaml) const
{
	Yaml << YAML::BeginMap;

	Weightclass::ToString(Yaml);

	Yaml << YAML::EndMap;
}



std::string SingleElimination::GetHTMLForm()
{
	return Weightclass::GetHTMLForm();
}



void SingleElimination::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	if (GetParticipants().size() <= 3)
		m_RecommendedNumMatches_Before_Break = 1;
	else
		m_RecommendedNumMatches_Before_Break = 2;

	if (GetParticipants().size() == 2)
		AddAutoMatch(0, 1);

	else if (GetParticipants().size() == 3)
	{
		AddAutoMatch(0, 1);
		AddAutoMatch(0, 2);
		AddAutoMatch(1, 2);
	}

	else if (GetParticipants().size() == 4)
	{
		AddAutoMatch(0, 1);
		AddAutoMatch(2, 3);

		AddAutoMatch(0, 2);
		AddAutoMatch(1, 3);

		AddAutoMatch(0, 3);
		AddAutoMatch(1, 2);
	}

	else if (GetParticipants().size() == 5)
	{
		AddAutoMatch(0, 1);
		AddAutoMatch(2, 3);
		AddAutoMatch(0, 4);

		AddAutoMatch(1, 2);
		AddAutoMatch(3, 4);
		AddAutoMatch(0, 2);

		AddAutoMatch(1, 3);
		AddAutoMatch(2, 4);
		AddAutoMatch(0, 3);

		AddAutoMatch(1, 4);
	}

	else
	{
		for (size_t white = 0; white < GetParticipants().size(); ++white)
			for (size_t blue = white + 1; blue < GetParticipants().size(); ++blue)
			{
				if (white != blue)
					AddAutoMatch(white, blue);
			}

		auto rng = std::default_random_engine{};
		std::shuffle(std::begin(m_Schedule), std::end(m_Schedule), rng);
	}

	
	//Add additional matches for best of three
	if (IsBestOfThree())
	{
		auto length = m_Schedule.size();
		for (size_t i = 0; i < length; ++i)
		{
			auto match1 = m_Schedule[i];
			auto indices = GetIndicesOfMatch(match1);

			auto match2 = AddAutoMatch(indices.second, indices.first);
			auto match3 = AddAutoMatch(indices.first,  indices.second);
			if (match3)
				match3->SetBestOfThree(match1, match2);
		}
	}


	for (auto match : m_Schedule)
		match->SetMatchTable(this);
}



std::vector<MatchTable::Result> SingleElimination::CalculateResults() const
{
	std::vector<Result> ret(GetParticipants().size());

	for (size_t i = 0; i < GetParticipants().size(); i++)
	{
		auto fighter = GetParticipant(i);
		ret[i].Set(fighter, this);		
	}

	for (auto match : m_Schedule)
	{
		if (!match->HasConcluded())
			continue;

		const auto& result = match->GetMatchResult();

		auto i = GetIndexOfParticipant(match->GetWinner());
		auto j = GetIndexOfParticipant(match->GetLoser());

		ret[i].Wins++;
		ret[i].Score += (uint32_t)result.m_Score;

		ret[i].Time += result.m_Time;
		ret[j].Time += result.m_Time;
	}

	std::sort(ret.begin(), ret.end());

	return ret;
}



const std::string SingleElimination::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	ret += R"(<table width="50%" border="1" rules="all">)";

	//auto results = CalculateResults();

	const auto N = GetParticipants().size();
	int rounds = (int)std::floor(std::log2(GetParticipants().size())) + 1;

	auto renderMatch = [this, N](int roundIndex, int matchOfRound) -> std::string {
		int matchIndex = 0;
		for (int i = 1; i <= roundIndex; ++i)
			matchIndex += (int)(N / pow(2.0, i));

		matchIndex += matchOfRound;

		if (matchIndex >= GetSchedule().size())
			return "";

		auto match = GetSchedule()[matchIndex];

		std::string ret;

		ret += "<td>";

		if (match->GetFighter(Fighter::White))
			ret += match->GetFighter(Fighter::White)->GetName();
		else
			ret += "???";

		ret += " vs. ";

		if (match->GetFighter(Fighter::Blue))
			ret += match->GetFighter(Fighter::Blue)->GetName();
		else
			ret += "???";

		"</td>";

		return ret;
	};




	for (int y = 0; y < 2*N; ++y)
	{
		ret += "<tr>";

		int matchOfRound = 0;
		for (int round = 0; round < rounds; ++round)
		{
			if (y%2 == 1)
			{
				ret += "<td> </td>";
				continue;
			}

			ret += renderMatch(round, matchOfRound);
			matchOfRound++;
		}

		ret += "</tr>";
	}
	

	return ret;
}