#include <algorithm>
#include <random>
#include "single_elimination.h"
#include "tournament.h"
#include "localizer.h"
#include "match.h"



using namespace Judoboard;



SingleElimination::SingleElimination(Weight MinWeight, Weight MaxWeight, const ITournament* Tournament)
	: Weightclass(MinWeight, MaxWeight, Tournament)
{
}



SingleElimination::SingleElimination(const YAML::Node& Yaml, ITournament* Tournament)
	: Weightclass(Yaml, Tournament)
{
	if (Yaml["third_place_match"])
		m_ThirdPlaceMatch = Yaml["third_place_match"].as<bool>();
	if (Yaml["fifth_place_match"])
		m_FifthPlaceMatch = Yaml["fifth_place_match"].as<bool>();

	if (Yaml["starting_positions"] && Yaml["starting_positions"].IsMap() && Tournament)
	{
		for (const auto& node : Yaml["starting_positions"])
			m_StartingPositions.insert({ node.first.as<int>(), Tournament->FindParticipant(node.second.as<std::string>())  });
	}
}



void SingleElimination::operator >> (YAML::Emitter& Yaml) const
{
	Weightclass::operator >>(Yaml);

	if (m_ThirdPlaceMatch)
		Yaml << YAML::Key << "third_place_match" << YAML::Value << m_ThirdPlaceMatch;
	if (m_FifthPlaceMatch)
		Yaml << YAML::Key << "fifth_place_match" << YAML::Value << m_FifthPlaceMatch;

	if (!m_StartingPositions.empty())
	{
		Yaml << YAML::Key << "starting_positions" << YAML::Value;
		Yaml << YAML::BeginMap;
		for (const auto [starting_pos, judoka] : m_StartingPositions)
			Yaml << YAML::Key << starting_pos << YAML::Value << (std::string)judoka->GetUUID();
		Yaml << YAML::EndMap;
	}
}



void SingleElimination::ToString(YAML::Emitter& Yaml) const
{
	Weightclass::ToString(Yaml);

	Yaml << YAML::Key << "3rd_place" << YAML::Value << IsThirdPlaceMatch();
	Yaml << YAML::Key << "5th_place" << YAML::Value << IsFifthPlaceMatch();
}



std::string SingleElimination::GetHTMLForm()
{
	auto ret = Weightclass::GetHTMLForm();

	ret += R"(
<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf3">Match for 3rd place</label>
		<input type="checkbox" id="mf3" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf3">
		<span class="toggle-on" id="mf3_enabled"></span><span class="toggle-off" id="mf3_disabled"></span>
	</label>
</div>

<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf5">Match for 5th place</label>
		<input type="checkbox" id="mf5" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf5">
		<span class="toggle-on" id="mf5_enabled"></span><span class="toggle-off" id="mf5_disabled"></span>
	</label>
</div>
)";

	return ret;
}



bool SingleElimination::AddParticipant(Judoka* NewParticipant, bool Force)
{
	if (!MatchTable::AddParticipant(NewParticipant, Force))
		return false;

	for (size_t startPos = 0; true; startPos++)
	{
		if (!IsStartPositionTaken(startPos))
		{
			m_StartingPositions.insert({ startPos, NewParticipant });
			break;
		}
	}

	SortParticipantsByStartingPosition();
	GenerateSchedule();
	return true;
}



void SingleElimination::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	if (GetParticipants().size() <= 3)
		m_RecommendedNumMatches_Before_Break = 1;
	else
		m_RecommendedNumMatches_Before_Break = 2;

	if (GetParticipants().size() <= 1)
		return;

	const auto rounds = GetNumberOfRounds();
	const auto max_start_pos = pow(2, rounds);
	
	//Round 1
	std::vector<Match*> lastRound;
	std::vector<Match*> nextRound;

	for (size_t i = 0; i < max_start_pos; i += 2)
	{
		auto new_match = CreateAutoMatch(GetJudokaByStartPosition(i),
			                             GetJudokaByStartPosition(i+1));
		nextRound.emplace_back(new_match);
	}

	//Additional rounds
	for (int round = 1; round < rounds; ++round)
	{
		lastRound = std::move(nextRound);

		for (size_t i = 0; i < lastRound.size(); i += 2)
		{
			if (i+1 >= lastRound.size())
				break;

			auto match1 = lastRound[i];
			auto match2 = lastRound[i+1];

			auto new_match = AddMatchForWinners(match1, match2);
			nextRound.emplace_back(new_match);
		}
	}


	//Add additional match for 3rd place
	if (IsThirdPlaceMatch() && m_Schedule.size() >= 3)
	{
		auto match1 = m_Schedule[m_Schedule.size() - 3];
		auto match2 = m_Schedule[m_Schedule.size() - 2];

		auto third_place = CreateAutoMatch(nullptr, nullptr);
		third_place->SetDependency(Fighter::White, Match::DependencyType::TakeLoser, match1);
		third_place->SetDependency(Fighter::Blue,  Match::DependencyType::TakeLoser, match2);

		//Swap matches so that match for 1st place is still the last one
		std::swap(m_Schedule[m_Schedule.size() - 1], m_Schedule[m_Schedule.size() - 2]);
	}
	

	//Add additional matches for 5th place
	if (IsFifthPlaceMatch() && m_Schedule.size() >= 8)
	{
		int offset = 3;//Final and two semi finals
		if (IsThirdPlaceMatch())
			offset = 4;

		auto match1 = m_Schedule[m_Schedule.size() - 1 - offset - 3];
		auto match2 = m_Schedule[m_Schedule.size() - 1 - offset - 2];
		auto match3 = m_Schedule[m_Schedule.size() - 1 - offset - 1];
		auto match4 = m_Schedule[m_Schedule.size() - 1 - offset];

		//Order gets fixed at the end
		auto semi2 = CreateAutoMatch(nullptr, nullptr);
		auto fifth = CreateAutoMatch(nullptr, nullptr);
		auto semi1 = CreateAutoMatch(nullptr, nullptr);

		semi1->SetDependency(Fighter::White, Match::DependencyType::TakeLoser, match1);
		semi1->SetDependency(Fighter::Blue,  Match::DependencyType::TakeLoser, match2);

		semi2->SetDependency(Fighter::White, Match::DependencyType::TakeLoser, match3);
		semi2->SetDependency(Fighter::Blue,  Match::DependencyType::TakeLoser, match4);

		fifth->SetDependency(Fighter::White, Match::DependencyType::TakeWinner, semi1);
		fifth->SetDependency(Fighter::Blue,  Match::DependencyType::TakeWinner, semi2);

		//Swap matches so that match for 1st place is still the last one
		offset = 3;

		std::swap(m_Schedule[m_Schedule.size() - 1 - offset - 2], m_Schedule[m_Schedule.size() - 1 - 2]);
		std::swap(m_Schedule[m_Schedule.size() - 1 - offset - 1], m_Schedule[m_Schedule.size() - 1 - 1]);
		std::swap(m_Schedule[m_Schedule.size() - 1 - offset],     m_Schedule[m_Schedule.size() - 1]);

		if (IsThirdPlaceMatch())
			std::swap(m_Schedule[m_Schedule.size() - 1 - offset - 3], m_Schedule[m_Schedule.size() - 1 - 3]);
	}


	//Add additional matches for best of three
	if (IsBestOfThree())
	{
		auto schedule_copy = std::move(m_Schedule);

		auto length = schedule_copy.size();
		for (size_t i = 0; i < length; ++i)
		{
			auto match1 = schedule_copy[i];

			auto match2 = new Match(*match1);
			match2->SwapFighters();
			auto match3 = new Match(*match1);
			match3->SetBestOfThree(match1, match2);

			m_Schedule.push_back(match1);
			m_Schedule.emplace_back(match2);
			m_Schedule.emplace_back(match3);
		}

		//Fix references, matches should take the winner of the BO3 match not the first one
		for (auto match : m_Schedule)
		{
			if (match->GetDependencyTypeOf(Fighter::White) != Match::DependencyType::TakeWinner)
				continue;
			if (match->GetDependencyTypeOf(Fighter::Blue ) != Match::DependencyType::TakeWinner)
				continue;
			if (match->IsBestOfThree())
				continue;

			auto dependent_match1 = match->GetDependentMatchOf(Fighter::White);
			auto dependent_match2 = match->GetDependentMatchOf(Fighter::Blue);

			if (dependent_match1 && dependent_match2)
			{
				auto index1 = FindMatchIndex(dependent_match1->GetUUID());
				auto index2 = FindMatchIndex(dependent_match2->GetUUID());

				if (index1 != SIZE_MAX && index2 != SIZE_MAX)
				{
					if (index1 + 2 < m_Schedule.size())
						match->SetDependency(Fighter::White, Match::DependencyType::TakeWinner, m_Schedule[index1 + 2]);
					if (index2 + 2 < m_Schedule.size())
						match->SetDependency(Fighter::Blue,  Match::DependencyType::TakeWinner, m_Schedule[index2 + 2]);
				}
			}
		}
	}
}



std::vector<MatchTable::Result> SingleElimination::CalculateResults() const
{
	std::vector<Result> ret;

	if (GetParticipants().size() == 1)
	{
		ret.emplace_back(GetParticipants()[0], this);
		return ret;
	}

	//Get final match
	const Match* lastMatch = m_Schedule[m_Schedule.size() - 1];

	if (lastMatch->HasConcluded())
	{
		ret.emplace_back(lastMatch->GetWinner(), this);
		ret.emplace_back(lastMatch->GetLoser(),  this);
	}
	else
		return ret;

	if (IsThirdPlaceMatch())
	{
		const Match* third_place_match = m_Schedule[m_Schedule.size() - 2];
		ret.emplace_back(third_place_match->GetWinner(), this);
		ret.emplace_back(third_place_match->GetLoser(),  this);
	}

	if (IsThirdPlaceMatch() && IsFifthPlaceMatch())
	{
		//int offset = 4;
		//if (IsThirdPlaceMatch())
		//offset = 5;

		int offset = 5;

		const Match* fifth_place_match = m_Schedule[m_Schedule.size() - offset];
		ret.emplace_back(fifth_place_match->GetWinner(), this);
		ret.emplace_back(fifth_place_match->GetLoser(),  this);
	}

	return ret;
}



size_t SingleElimination::GetStartingPosition(const Judoka* Judoka) const
{
	if (!Judoka)
		return 0;

	for (auto [pos, participant] : m_StartingPositions)
	{
		if (participant && participant->GetUUID() == Judoka->GetUUID())
			return pos;
	}

	return 0;
}



void SingleElimination::SetStartingPosition(const Judoka* Judoka, size_t NewStartingPosition)
{
	if (!Judoka)
		return;

	auto my_old_pos = GetStartingPosition(Judoka);
	m_StartingPositions.erase(my_old_pos);

	if (IsStartPositionTaken(NewStartingPosition))
	{
		auto judoka_on_slot = GetJudokaByStartPosition(NewStartingPosition);

		m_StartingPositions.erase(my_old_pos);
		m_StartingPositions.erase(GetStartingPosition(judoka_on_slot));
		m_StartingPositions.insert({ my_old_pos, judoka_on_slot });
		m_StartingPositions.insert({ NewStartingPosition, Judoka });
	}

	else
	{
		m_StartingPositions.erase(GetStartingPosition(Judoka));
		m_StartingPositions.insert({ NewStartingPosition, Judoka });
	}

	SortParticipantsByStartingPosition();
}



const std::string SingleElimination::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	ret += "<table width='50%' border='1' rules='all'>";

	//auto results = CalculateResults();

	const auto rounds = GetNumberOfRounds();
	const auto N = pow(2, rounds);

	auto renderMatch = [this, N](int roundIndex, int matchOfRound) -> std::string {
		int matchIndex = 0;
		for (int i = 1; i <= roundIndex; ++i)
			matchIndex += (int)(N / pow(2.0, i));

		matchIndex += matchOfRound;

		if (IsThirdPlaceMatch() && matchIndex >= GetSchedule().size() - 2)
			matchIndex++;
		if (IsFifthPlaceMatch() && matchIndex >= GetSchedule().size() - 5)
			matchIndex+=3;

		if (IsBestOfThree())
			matchIndex = matchIndex*3;

		if (matchIndex >= GetSchedule().size())
			return "";

		auto match = GetSchedule()[matchIndex];

		std::string ret = "<td>";

		if (!match->IsEmptyMatch())
			ret += "<a href='#edit_match.html?id=" + (std::string)match->GetUUID() + "'>";
		
		//Output name of fighters
		if (match->GetFighter(Fighter::White))
			ret += match->GetFighter(Fighter::White)->GetName(NameStyle::GivenName);
		else if (match->HasDependentMatches())
			ret += "???";
		else
			ret += "- - -";

		ret += " vs. ";

		if (match->GetFighter(Fighter::Blue))
			ret += match->GetFighter(Fighter::Blue)->GetName(NameStyle::GivenName);
		else if (match->HasDependentMatches())
			ret += "???";
		else
			ret += "- - -";

		//Output result
		if (match->IsRunning())
			ret += "<br/>" + Localizer::Translate("In Progress");
		else if (match->HasConcluded())
		{
			const auto& result = match->GetResult();
			if (result.m_Winner == Winner::White)
				ret += "<br/>"   + std::to_string((int)result.m_Score) + ":0";
			else
				ret += "<br/>0:" + std::to_string((int)result.m_Score);

			ret += " (" + Timer::TimestampToString(result.m_Time) + ")";
		}

		if (!match->IsEmptyMatch())
			ret += "</a>";
		ret += "</a></td>";

		return ret;
	};


	ret += "<tr style='height: 5mm; text-align: center'>";
	for (int round = 0; round < rounds; ++round)
		ret += "<th>" + Localizer::Translate("Round") + " " + std::to_string(round + 1) + "</th>";
	ret += "</tr>";

	for (int y = 0; y < N; ++y)
	{
		ret += "<tr style='height: 5mm; text-align: center'>";

		for (int round = 0; round < rounds; ++round)
		{
			if ( (y + (int)std::pow(2, round) + 1) % (int)std::pow(2, round+1) != 0)
			{
				ret += "<td></td>";
				continue;
			}

			const int matchOfRound = y / (int)std::pow(2, round+1);
			ret += renderMatch(round, matchOfRound);
		}

		ret += "</tr>";
	}

	ret += "</table>";
	

	return ret;
}