#include <algorithm>
#include <random>
#include "round_robin.h"
#include "weightclass.h"
#include "tournament.h"
#include "localizer.h"
#include "match.h"
#include "timer.h"



using namespace Judoboard;



RoundRobin::RoundRobin(IFilter* Filter, const ITournament* Tournament)
	: MatchTable(Filter, Tournament)
{
}



RoundRobin::RoundRobin(Weight MinWeight, Weight MaxWeight, Gender Gender, const ITournament* Tournament)
	: MatchTable(new Weightclass(MinWeight, MaxWeight, Gender, Tournament), Tournament)
{
}



RoundRobin::RoundRobin(const YAML::Node& Yaml, const ITournament* Tournament)
	: MatchTable(Yaml, Tournament)
{
}



RoundRobin::RoundRobin(const MD5::Weightclass& Weightclass_, const ITournament* Tournament)
	: MatchTable(new Weightclass(Weightclass_, Tournament), Tournament)
{
	SetName(Weightclass_.Description);
}



std::string RoundRobin::GetHTMLForm()
{
	std::string ret;

	if (GetFilter())
		ret += GetFilter()->GetHTMLForm();

	ret += MatchTable::GetHTMLForm();

	return ret;
}



void RoundRobin::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	if (GetParticipants().size() <= 3)
		m_RecommendedNumMatches_Before_Break = 1;
	else
		m_RecommendedNumMatches_Before_Break = 2;

	if (GetParticipants().size() == 2)
		AddAutoMatch(1, 0);

	else if (GetParticipants().size() == 3)
	{
		AddAutoMatch(2, 0);
		AddAutoMatch(1, 0);
		AddAutoMatch(2, 1);
	}

	else if (GetParticipants().size() == 4)
	{
		AddAutoMatch(2, 0);
		AddAutoMatch(3, 1);

		AddAutoMatch(3, 0);
		AddAutoMatch(2, 1);

		AddAutoMatch(1, 0);
		AddAutoMatch(3, 2);
	}

	else if (GetParticipants().size() == 5)
	{
		AddAutoMatch(3, 0);
		AddAutoMatch(4, 1);

		AddAutoMatch(2, 0);
		AddAutoMatch(3, 1);

		AddAutoMatch(4, 2);
		AddAutoMatch(1, 0);

		AddAutoMatch(3, 2);
		AddAutoMatch(4, 0);

		AddAutoMatch(2, 1);
		AddAutoMatch(4, 3);
	}

	else if (GetParticipants().size() == 6)
	{
		AddAutoMatch(3, 0);
		AddAutoMatch(4, 1);
		AddAutoMatch(5, 2);

		AddAutoMatch(3, 1);
		AddAutoMatch(4, 0);

		AddAutoMatch(5, 1);
		AddAutoMatch(2, 0);

		AddAutoMatch(5, 3);
		AddAutoMatch(4, 2);
		AddAutoMatch(1, 0);

		AddAutoMatch(4, 3);
		AddAutoMatch(5, 0);
		AddAutoMatch(2, 1);

		AddAutoMatch(5, 4);
		AddAutoMatch(3, 2);
	}

	else
	{
		for (size_t blue = 0; blue < GetMaxStartPositions(); ++blue)
			for (size_t white = blue + 1; white < GetMaxStartPositions(); ++white)
			{
				AddAutoMatch(white, blue);
			}

		auto rng = std::default_random_engine{};
		std::shuffle(std::begin(m_Schedule), std::end(m_Schedule), rng);
	}

	
	//Add additional matches for best of three
	if (IsBestOfThree())
		AddMatchesForBestOfThree();
}



MatchTable::Results RoundRobin::CalculateResults() const
{
	MatchTable::Results results(*this);

	for (auto match : GetSchedule())
	{
		if (!match->HasConcluded())
			continue;

		const auto& result = match->GetResult();

		auto winner = results.GetResultsOf(match->GetWinner());
		auto loser  = results.GetResultsOf(match->GetLoser());

		winner->Wins++;
		winner->Score += (uint32_t)result.m_Score;
		winner->Time  += result.m_Time;

		loser->Time += result.m_Time;
	}

	results.Sort();

	return results;
}



const std::string RoundRobin::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	ret += R"(<table width="50%" border="1" rules="all"><tr><th style="text-align: center;">)" + Localizer::Translate("No.")
		+ "</th><th style=\"width: 5.0cm;\">" + Localizer::Translate("Name") + "</th>";

	for (uint32_t j = 0; j < GetParticipants().size(); j++)//Number of fights + 1
		ret += "<th>vs " + GetParticipants()[j]->GetName(NameStyle::GivenName) + "</th>";

	ret += "<th style=\"text-align: center; width: 2.0cm;\">Total</th>";
	ret += "</tr>";

	auto results = CalculateResults();

	for (size_t i = 0; i < GetMaxStartPositions(); ++i)
	{
		if (!GetJudokaByStartPosition(i))
			continue;

		auto fighter = GetJudokaByStartPosition(i)->GetJudoka();

		if (!fighter)
			continue;

		ret += "<tr>";
		ret += "<td style=\"text-align: center;\">" + std::to_string(i+1) + "</td>";
		ret += "<td>" + fighter->GetName(NameStyle::GivenName) + "<br/>(" + fighter->GetWeight().ToString() + " kg)</td>";

		for (size_t j = 0; j < GetMaxStartPositions(); ++j)
		{
			if (!GetJudokaByStartPosition(j))
				continue;

			auto enemy = GetJudokaByStartPosition(j)->GetJudoka();
			if (!enemy)
				continue;

			auto matches = FindMatches(*fighter, *enemy);

			if (matches.empty())
				ret += "<td style=\"background-color: #ccc;\"></td>";
			else
			{
				if (matches[0]->IsRunning())
					ret += "<td style=\"text-align: center;\"><a href=\"#edit_match.html?id=" + (std::string)matches[0]->GetUUID() + "\">In Progress</a></td>";
				else if (!matches[0]->HasConcluded())
					ret += "<td style=\"text-align: center;\"><a href=\"#edit_match.html?id=" + (std::string)matches[0]->GetUUID() + "\">- - -</a></td>";
				else if (matches[0]->GetWinner()->GetUUID() == fighter->GetUUID())
				{
					const auto& result = matches[0]->GetResult();
					ret += "<td style=\"text-align: center;\"><a href=\"#edit_match.html?id=" + (std::string)matches[0]->GetUUID() + "\">" + std::to_string((int)result.m_Score) + " (" + Timer::TimestampToString(result.m_Time) + ")</a></td>";
				}
				else
				{
					const auto& result = matches[0]->GetResult();
					ret += "<td style=\"text-align: center;\"><a href=\"#edit_match.html?id=" + (std::string)matches[0]->GetUUID() + "\">0 (" + Timer::TimestampToString(result.m_Time) + ")</a></td>";
				}
			}
		}

		const auto result = results.GetResultsOf(fighter);
		if (result)
			ret += "<td style=\"text-align: center;\">" + std::to_string(result->Wins) + " : " + std::to_string(result->Score) + "<br/>(" + Timer::TimestampToString(result->Time) + ")</td>";

		ret += "</tr>";
	}

	ret += ResultsToHTML();

	return ret;
}