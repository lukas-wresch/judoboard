#include <algorithm>
#include <random>
#include "pool.h"
#include "round_robin.h"
#include "weightclass.h"
#include "splitter.h"
#include "take_top_ranks.h"
#include "fuser.h"
#include "rule_set.h"
#include "localizer.h"
#include "match.h"



using namespace Judoboard;



Pool::Pool(Weight MinWeight, Weight MaxWeight, Gender Gender, const ITournament* Tournament)
	: Pool(new Weightclass(MinWeight, MaxWeight, Gender, Tournament), Tournament)
{
}



Pool::Pool(const YAML::Node& Yaml, ITournament* Tournament)
	: MatchTable(Yaml, Tournament), m_Finals(nullptr, Tournament)
{
	if (Yaml["pool_count"])
		SetPoolCount(Yaml["pool_count"].as<uint32_t>());
	if (Yaml["take_top"])
		SetTakeTop(Yaml["take_top"].as<uint32_t>());

	if (Yaml["third_place_match"])
		IsThirdPlaceMatch(Yaml["third_place_match"].as<bool>());
	if (Yaml["fifth_place_match"])
		IsFifthPlaceMatch(Yaml["fifth_place_match"].as<bool>());
}



void Pool::operator >> (YAML::Emitter& Yaml) const
{
	MatchTable::operator >>(Yaml);

	Yaml << YAML::Key << "pool_count" << YAML::Value << m_PoolCount;
	Yaml << YAML::Key << "take_top"   << YAML::Value << m_TakeTop;

	if (IsThirdPlaceMatch())
		Yaml << YAML::Key << "third_place_match" << YAML::Value << IsThirdPlaceMatch();
	if (IsFifthPlaceMatch())
		Yaml << YAML::Key << "fifth_place_match" << YAML::Value << IsFifthPlaceMatch();
}



void Pool::ToString(YAML::Emitter& Yaml) const
{
	MatchTable::ToString(Yaml);

	Yaml << YAML::Key << "third_place" << YAML::Value << IsThirdPlaceMatch();
	Yaml << YAML::Key << "fifth_place" << YAML::Value << IsFifthPlaceMatch();
}



std::string Pool::GetHTMLForm()
{
	std::string ret = R"(
<div>
  <label style="width:150px;float:left;margin-top:5px;" id="label_pool">#Pools</label>
  <select style="margin-bottom:20px;" id="pool_count">
    <option selected value="0" id="auto">Auto</option>
    <option value="2">2</option>
	<option value="4">4</option>
	<option value="8">8</option>
  </select>
</div>

<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf3">Match for 3rd place</label>
		<input type="checkbox" id="mf3" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf3">
		<span class="toggle-on" id="mf3_enabled"></span><span class="toggle-off" id="mf3_disabled"></span>
	</label>
</div>

<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf5">Match for 5th place</label>
		<input type="checkbox" id="mf5" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf5">
		<span class="toggle-on" id="mf5_enabled"></span><span class="toggle-off" id="mf5_disabled"></span>
	</label>
</div>
)";

	return ret;
}



size_t Pool::GetMaxStartPositions() const
{
	if (!GetFilter())
		return 0;

	const size_t pool_count = CalculatePoolCount();

	return ( (size_t)std::floor(GetFilter()->GetParticipants().size() / pool_count) ) * pool_count;
}



void Pool::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	m_RecommendedNumMatches_Before_Break = 4;//TODO

	if (!GetFilter() || GetParticipants().size() <= 1)
		return;

	for (auto pool : m_Pools)
		delete pool;

	m_Pools.clear();

	const auto pool_count = CalculatePoolCount();
	m_Pools.resize(pool_count);

	//Distribute participants to pools
	for (int i = 0; i < pool_count; ++i)
		m_Pools[i] = new RoundRobin(new Splitter(*GetFilter(), pool_count, i));

	//Create filter(s) for final round
	auto fuser = new Fuser(GetTournament());
	for (auto pool : m_Pools)
	{
		auto take_top_placed = new TakeTopRanks(*pool, m_TakeTop);
		fuser->AddSource(*take_top_placed);
	}

	m_Finals = std::move(SingleElimination(fuser));

	//Add matches from pools
	size_t index = 0;
	bool added;
	do
	{
		added = false;
		for (int pool = 0; pool < pool_count; ++pool)
		{
			auto schedule = GetPool(pool)->GetSchedule();

			if (index >= schedule.size())
				continue;

			AddMatch(schedule[index]);
			added = true;
		}

		++index;
	} while (added);//Still matches to add?

	//Add matches for single elimination phase
	for (auto match : m_Finals.GetSchedule())
		AddMatch(match);
}



const std::string Pool::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	for (auto pool : m_Pools)
		ret += pool->ToHTML();

	ret += m_Finals.ToHTML();

	//ret += ResultsToHTML();	

	return ret;
}