#include <algorithm>
#include <random>
#include "pool.h"
#include "tournament.h"
#include "localizer.h"
#include "match.h"



using namespace Judoboard;



Pool::Pool(Weight MinWeight, Weight MaxWeight, const ITournament* Tournament)
	: Weightclass(MinWeight, MaxWeight, Tournament), m_Finals(MinWeight, MaxWeight, Tournament)
{
}



Pool::Pool(const YAML::Node& Yaml, ITournament* Tournament)
	: Weightclass(Yaml, Tournament), m_Finals(0, 0, Tournament)
{
	if (Yaml["pool_count"])
		m_PoolCount = Yaml["pool_count"].as<bool>();

	if (Yaml["third_place_match"])
		m_Finals.IsThirdPlaceMatch(Yaml["third_place_match"].as<bool>());
	if (Yaml["fifth_place_match"])
		m_Finals.IsFifthPlaceMatch(Yaml["fifth_place_match"].as<bool>());

	if (Yaml["starting_positions"] && Yaml["starting_positions"].IsMap() && Tournament)
	{
		for (const auto& node : Yaml["starting_positions"])
			m_StartingPositions.insert({ node.first.as<int>(), Tournament->FindParticipant(node.second.as<std::string>())  });
	}
}



void Pool::operator >> (YAML::Emitter& Yaml) const
{
	Weightclass::operator >>(Yaml);

	/*if (m_ThirdPlaceMatch)
		Yaml << YAML::Key << "third_place_match" << YAML::Value << m_ThirdPlaceMatch;
	if (m_FifthPlaceMatch)
		Yaml << YAML::Key << "fifth_place_match" << YAML::Value << m_FifthPlaceMatch;*/

	if (!m_StartingPositions.empty())
	{
		Yaml << YAML::Key << "starting_positions" << YAML::Value;
		Yaml << YAML::BeginMap;
		for (const auto [starting_pos, judoka] : m_StartingPositions)
			Yaml << YAML::Key << starting_pos << YAML::Value << (std::string)judoka->GetUUID();
		Yaml << YAML::EndMap;
	}
}



void Pool::ToString(YAML::Emitter& Yaml) const
{
	Weightclass::ToString(Yaml);

	//Yaml << YAML::Key << "third_place" << YAML::Value << IsThirdPlaceMatch();
	//Yaml << YAML::Key << "fifth_place" << YAML::Value << IsFifthPlaceMatch();
}



std::string Pool::GetHTMLForm()
{
	auto ret = Weightclass::GetHTMLForm();

	ret += R"(
<div>
  <label style="width:150px;float:left;margin-top:5px;" id="label_pool">#Pools</label>
  <select style="margin-bottom:20px;" id="pool_count">
    <option selected value="0" id="auto">Auto</option>
    <option value="2">2</option>
	<option value="4">4</option>
	<option value="8">8</option>
  </select>
</div>

<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf3">Match for 3rd place</label>
		<input type="checkbox" id="mf3" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf3">
		<span class="toggle-on" id="mf3_enabled"></span><span class="toggle-off" id="mf3_disabled"></span>
	</label>
</div>

<div>
	<label style="width:150px;float:left;margin-top:5px;" id="label_mf5">Match for 5th place</label>
		<input type="checkbox" id="mf5" class="switch-input">
		<label style="padding-top:0px;padding-bottom:0px;margin-top:5px;margin-bottom:20px;" class="switch-label" for="mf5">
		<span class="toggle-on" id="mf5_enabled"></span><span class="toggle-off" id="mf5_disabled"></span>
	</label>
</div>
)";

	return ret;
}



bool Pool::AddParticipant(const Judoka* NewParticipant, bool Force)
{
	if (!MatchTable::AddParticipant(NewParticipant, Force))
		return false;

	for (size_t startPos = 0; true; startPos++)
	{
		if (!IsStartPositionTaken(startPos))
		{
			m_StartingPositions.insert({ startPos, NewParticipant });
			break;
		}
	}

	SortParticipantsByStartingPosition();
	GenerateSchedule();
	return true;
}



void Pool::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	m_RecommendedNumMatches_Before_Break = 4;//TODO

	if (GetParticipants().size() <= 1)
		return;

	const auto max_start_pos = std::floor(GetParticipants().size() / m_PoolCount) * m_PoolCount;

	for (auto pool : m_Pools)
		delete pool;

	m_Pools.clear();
	m_Pools.resize(m_PoolCount);

	for (int i = 0; i < m_PoolCount; ++i)
		m_Pools[i] = new Weightclass(GetMinWeight(), GetMaxWeight(), GetTournament());

	//Distribute participants to pools
	for (int pos = 0; pos < max_start_pos; ++pos)
	{
		auto judoka = GetJudokaByStartPosition(pos);

		if (!judoka)
			continue;

		int pool = pos % m_PoolCount;

		m_Pools[pool]->AddParticipant(judoka, true);
	}
}



size_t Pool::GetStartingPosition(const Judoka* Judoka) const
{
	if (!Judoka)
		return 0;

	for (auto [pos, participant] : m_StartingPositions)
	{
		if (participant && participant->GetUUID() == Judoka->GetUUID())
			return pos;
	}

	return 0;
}



void Pool::SetStartingPosition(const Judoka* Judoka, size_t NewStartingPosition)
{
	if (!Judoka)
		return;

	auto my_old_pos = GetStartingPosition(Judoka);
	m_StartingPositions.erase(my_old_pos);

	if (IsStartPositionTaken(NewStartingPosition))
	{
		auto judoka_on_slot = GetJudokaByStartPosition(NewStartingPosition);

		m_StartingPositions.erase(my_old_pos);
		m_StartingPositions.erase(GetStartingPosition(judoka_on_slot));
		m_StartingPositions.insert({ my_old_pos, judoka_on_slot });
		m_StartingPositions.insert({ NewStartingPosition, Judoka });
	}

	else
	{
		m_StartingPositions.erase(GetStartingPosition(Judoka));
		m_StartingPositions.insert({ NewStartingPosition, Judoka });
	}

	SortParticipantsByStartingPosition();
}



const std::string Pool::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	ret += "<table border='1' rules='all'>";

	//TODO

	ret += "</table>";

	ret += ResultsToHTML();	

	return ret;
}