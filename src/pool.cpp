#include <algorithm>
#include <random>
#include "pool.h"
#include "round_robin.h"
#include "weightclass.h"
#include "splitter.h"
#include "take_top_ranks.h"
#include "reverser.h"
#include "fuser.h"
#include "mixer.h"
#include "fixed.h"
#include "rule_set.h"
#include "localizer.h"
#include "match.h"



using namespace Judoboard;



Pool::Pool(IFilter* Filter, const ITournament* Tournament)
	: MatchTable(Filter, Tournament), m_Finals(nullptr, Tournament)
{
	m_Finals.IsSubMatchTable(true);
	GenerateSchedule();
}



Pool::Pool(Weight MinWeight, Weight MaxWeight, Gender Gender, const ITournament* Tournament)
	: Pool(new Weightclass(MinWeight, MaxWeight, Gender, Tournament), Tournament)
{
}



Pool::Pool(const YAML::Node& Yaml, ITournament* Tournament)
	: MatchTable(Yaml, Tournament), m_Finals(nullptr, Tournament)
{
	m_Finals.IsSubMatchTable(true);

	if (Yaml["pool_count"])
		m_PoolCount = Yaml["pool_count"].as<uint32_t>();
	if (Yaml["take_top"])
		m_TakeTop   = Yaml["take_top"].as<uint32_t>();

	if (Yaml["third_place_match"])
		m_Finals.IsThirdPlaceMatch(Yaml["third_place_match"].as<bool>());
	if (Yaml["fifth_place_match"])
		m_Finals.IsFifthPlaceMatch(Yaml["fifth_place_match"].as<bool>());

	const auto pool_count = CalculatePoolCount();
	m_Pools.resize(pool_count);

	for (int i = 0; i < pool_count; ++i)
		m_Pools[i] = new RoundRobin(nullptr);

	//Check if pools have specific data
	for (size_t i = 0; i < m_Pools.size(); ++i)
	{
		if (Yaml["mat_of_pool_" + std::to_string(i)])
			m_Pools[i]->SetMatID(Yaml["mat_of_pool_" + std::to_string(i)].as<uint32_t>());
		if (Yaml["name_of_pool_" + std::to_string(i)])
			m_Pools[i]->SetName(Yaml["name_of_pool_" + std::to_string(i)].as<std::string>());
	}

	if (Yaml["mat_of_finals"])
		GetFinals().SetMatID(Yaml["mat_of_finals"].as<uint32_t>());
	GetFinals().SetName(Yaml["name_of_finals"].as<std::string>());
}



void Pool::operator >> (YAML::Emitter& Yaml) const
{
	MatchTable::operator >>(Yaml);

	Yaml << YAML::Key << "pool_count" << YAML::Value << m_PoolCount;
	Yaml << YAML::Key << "take_top"   << YAML::Value << m_TakeTop;

	if (IsThirdPlaceMatch())
		Yaml << YAML::Key << "third_place_match" << YAML::Value << IsThirdPlaceMatch();
	if (IsFifthPlaceMatch())
		Yaml << YAML::Key << "fifth_place_match" << YAML::Value << IsFifthPlaceMatch();

	//Serialize mats of pools if they differ
	for (size_t i = 0; i < m_Pools.size(); ++i)
	{
		if (m_Pools[i]->GetMatID() != 0)
			Yaml << YAML::Key << "mat_of_pool_" + std::to_string(i) << YAML::Value << m_Pools[i]->GetMatID();
		Yaml << YAML::Key << "name_of_pool_" + std::to_string(i) << YAML::Value << m_Pools[i]->GetName();
	}

	if (GetFinals().GetMatID() != 0 && GetFinals().GetMatID() != GetMatID())
		Yaml << YAML::Key << "mat_of_finals" << YAML::Value << GetFinals().GetMatID();
	Yaml << YAML::Key << "name_of_finals" << YAML::Value << GetFinals().GetName();
}



void Pool::ToString(YAML::Emitter& Yaml) const
{
	MatchTable::ToString(Yaml);

	Yaml << YAML::Key << "third_place" << YAML::Value << IsThirdPlaceMatch();
	Yaml << YAML::Key << "fifth_place" << YAML::Value << IsFifthPlaceMatch();
}



std::string Pool::GetHTMLForm()
{
	std::string ret = R"(
<div>
  <label style="width:150px;float:left;margin-top:5px;" id="label_pool">#Pools</label>
  <select style="margin-bottom:20px;" id="pool_count">
    <option selected value="0" id="auto">Auto</option>
    <option value="2">2</option>
	<option value="4">4</option>
	<option value="8">8</option>
  </select>
</div>
)";

	ret += SingleElimination::GetHTMLForm();

	return ret;
}



size_t Pool::GetMaxStartPositions() const
{
	if (!GetFilter())
		return 0;

	const size_t pool_count = CalculatePoolCount();

	return ( (size_t)std::floor(GetFilter()->GetParticipants().size() / pool_count) ) * pool_count;
}



void Pool::GenerateSchedule()
{
	for (auto it = m_Schedule.begin(); it != m_Schedule.end();)
	{
		if ((*it)->IsAutoGenerated())
			it = m_Schedule.erase(it);
		else
			++it;
	}

	m_RecommendedNumMatches_Before_Break = 4;//TODO

	if (!GetFilter() || GetParticipants().size() <= 1)
		return;
	
	auto old_pools = std::move(m_Pools);
	assert(m_Pools.empty());

	const auto pool_count = CalculatePoolCount();
	m_Pools.resize(pool_count);

	const char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

	//Distribute participants to pools
	for (int i = 0; i < pool_count; ++i)
	{
		m_Pools[i] = new RoundRobin(new Splitter(*GetFilter(), pool_count, i));

		std::string name = Localizer::Translate("Pool") + " ";
		name.append(&letters[i%26], 1);
		m_Pools[i]->SetName(name);
		m_Pools[i]->IsSubMatchTable(true);

		//Convert from old pools
		if (i < old_pools.size())
		{
			m_Pools[i]->SetName(old_pools[i]->GetName());
			m_Pools[i]->SetColor(old_pools[i]->GetColor());
			m_Pools[i]->SetMatID(old_pools[i]->GetMatID());
			m_Pools[i]->IsBestOfThree(old_pools[i]->IsBestOfThree());
		}
	}

	for (auto old_pools : old_pools)
		delete old_pools;

	//Create filter(s) for final round
	IFilter* final_input = nullptr;

	if (pool_count == 2)
	{
		TakeTopRanks topA(*m_Pools[0], m_TakeTop);
		TakeTopRanks topB(*m_Pools[1], m_TakeTop);

		Mixer mixer(GetTournament());

		mixer.AddSource(topA);
		mixer.AddSource(topB);

		final_input = new Fixed(mixer);
		
		if (m_TakeTop == 3)
		{
			auto temp = final_input->GetJudokaByStartPosition(4);
			if (temp)
				final_input->SetStartPosition(temp, 7);
			temp = final_input->GetJudokaByStartPosition(5);
			if (temp)
				final_input->SetStartPosition(temp, 6);
		}

		else
		{
			//Swap the two incorrect positions manually
			auto temp = final_input->GetJudokaByStartPosition(2);
			if (temp)
				final_input->SetStartPosition(temp, 3);
		}

#ifdef _DEBUG
		final_input->Dump();
#endif
	}

	else if (pool_count == 4)
	{
		Mixer mixer(GetTournament());

		TakeTopRanks topA(*m_Pools[0], m_TakeTop);
		TakeTopRanks topB(*m_Pools[1], m_TakeTop);
		TakeTopRanks topC(*m_Pools[2], m_TakeTop);
		TakeTopRanks topD(*m_Pools[3], m_TakeTop);

		mixer.AddSource(topA);
		mixer.AddSource(topB);
		mixer.AddSource(topC);
		mixer.AddSource(topD);

		final_input = new Fixed(mixer);

		auto temp = final_input->GetJudokaByStartPosition(4);
		if (temp)
			final_input->SetStartPosition(temp, 5);
		temp = final_input->GetJudokaByStartPosition(6);
		if (temp)
			final_input->SetStartPosition(temp, 7);

		//final_input->Dump();
	}

	else
	{
		auto mixer = new Mixer(GetTournament());

		for (int i = 0; i < pool_count; ++i)
		{
			IFilter* take_top_placed = new TakeTopRanks(*m_Pools[i], m_TakeTop);
			mixer->AddSource(*take_top_placed);
		}

		final_input = mixer;
	}


	assert(final_input);
	bool third_place = m_Finals.IsThirdPlaceMatch();
	bool fifth_place = m_Finals.IsFifthPlaceMatch();
	auto color       = m_Finals.GetColor();
	auto name        = m_Finals.GetName();
	auto mat_id      = m_Finals.GetMatID();

	m_Finals = std::move(SingleElimination(final_input));
	m_Finals.SetName(Localizer::Translate("Finals"));
	m_Finals.IsSubMatchTable(true);
	m_Finals.IsThirdPlaceMatch(third_place);
	m_Finals.IsFifthPlaceMatch(fifth_place);
	m_Finals.SetColor(color);
	if (!name.empty())
		m_Finals.SetName(name);
	m_Finals.SetMatID(mat_id);


	//Add matches from pools
	size_t index = 0;
	bool added;
	do
	{
		added = false;
		for (int pool = 0; pool < pool_count; ++pool)
		{
			auto schedule = GetPool(pool)->GetSchedule();

			if (index < schedule.size())
			{
				AddMatch(schedule[index]);
				added = true;
			}
		}

		++index;
	} while (added);//Still matches to add?


	//Add matches for single elimination phase
	for (auto match : m_Finals.GetSchedule())
		AddMatch(match);
}



const std::string Pool::ToHTML() const
{
	std::string ret;

	ret += "<a href=\"#matchtable_add.html?id=" + (std::string)GetUUID() + "\">" + GetDescription() + "</a>";

	ret += " / " + Localizer::Translate("Mat") + " " + std::to_string(GetMatID()) + " / " + GetRuleSet().GetName() + "<br/>";

	ret += "<br/>";

	for (auto pool : m_Pools)
		ret += pool->ToHTML() + "<br/><br/>";

	ret += m_Finals.ToHTML();

	//ret += ResultsToHTML();

	return ret;
}